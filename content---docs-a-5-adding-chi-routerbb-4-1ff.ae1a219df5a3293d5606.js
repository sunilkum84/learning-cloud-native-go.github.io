(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{54:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return i}),n.d(t,"rightToc",function(){return p}),n.d(t,"default",function(){return b});n(0);var a=n(70);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i={id:"a5.adding_chi_router",title:"Adding Chi router"},p=[],c={rightToc:p},l="wrapper";function b(e){var t=e.components,n=o(e,["components"]);return Object(a.b)(l,r({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"üí≠ The ",Object(a.b)("a",r({parentName:"p"},{href:"https://golang.org/pkg/net/http/#ServeMux"}),"default HTTP request multiplexer")," in ",Object(a.b)("a",r({parentName:"p"},{href:"https://golang.org/pkg/net/http/"}),Object(a.b)("inlineCode",{parentName:"a"},"net/http"))," is not very powerful. For example, if you visit ",Object(a.b)("inlineCode",{parentName:"p"},"localhost:8080/invalid-path")," it gives the same ",Object(a.b)("inlineCode",{parentName:"p"},"Hello World!")," response with ",Object(a.b)("inlineCode",{parentName:"p"},"200")," HTTP status instead giving ",Object(a.b)("inlineCode",{parentName:"p"},"404")," HTTP status. There are many powerful router libraries in Go like ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/gorilla/mux"}),Object(a.b)("inlineCode",{parentName:"a"},"gorilla/mux")),", ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/go-chi/chi"}),Object(a.b)("inlineCode",{parentName:"a"},"go-chi/chi")),", ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/julienschmidt/httprouter"}),Object(a.b)("inlineCode",{parentName:"a"},"julienschmidt/httprouter")),", ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/buaazp/fasthttprouter"}),Object(a.b)("inlineCode",{parentName:"a"},"buaazp/fasthttprouter")),". In here, we are using ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/go-chi/chi"}),Object(a.b)("strong",{parentName:"a"},Object(a.b)("inlineCode",{parentName:"strong"},"go-chi/chi")))," due to its lesser weight and extensibility.")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"We need to run ",Object(a.b)("inlineCode",{parentName:"li"},"go get github.com/go-chi/chi")," to download and install the package. As you know, this updates ",Object(a.b)("inlineCode",{parentName:"li"},"go.mod")," and ",Object(a.b)("inlineCode",{parentName:"li"},"go.sum")," files as well.")),Object(a.b)("p",null,"‚≠ê Instead of using ",Object(a.b)("inlineCode",{parentName:"p"},"cmd/app")," to store all application logic, it's a good practice to create a separate package to store the main application code and call it from ",Object(a.b)("inlineCode",{parentName:"p"},"cmd/app")," while creating the executable. So, I am creating the ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("inlineCode",{parentName:"strong"},"app"))," package ",Object(a.b)("strong",{parentName:"p"},"in the project root")," for this. However, you can name this as ",Object(a.b)("inlineCode",{parentName:"p"},"server")," or ",Object(a.b)("inlineCode",{parentName:"p"},"http"),", according to the purpose of the application."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Let's create a simple Handler which gives ",Object(a.b)("inlineCode",{parentName:"li"},"Hello World!")," text response. I save this under ",Object(a.b)("inlineCode",{parentName:"li"},"app/app/indexHandler.go"),". It's a simple function which matches ",Object(a.b)("a",r({parentName:"li"},{href:"https://golang.org/pkg/net/http/"}),Object(a.b)("inlineCode",{parentName:"a"},"net/http"))," handler signature ",Object(a.b)("inlineCode",{parentName:"li"},"func(ResponseWriter, *Request)")," to pass to ",Object(a.b)("a",r({parentName:"li"},{href:"https://golang.org/pkg/net/http/#ServeMux.HandleFunc"}),Object(a.b)("inlineCode",{parentName:"a"},"func (*ServeMux) HandleFunc"))," with a URL pattern.")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"In the next steps, we are going to build a struct which contains main dependencies like DB connection, under ",Object(a.b)("inlineCode",{parentName:"p"},"app/app")," to use them with handlers. If you don't like the name ",Object(a.b)("inlineCode",{parentName:"p"},"app/app"),"¬†, I recommend you to name this as ",Object(a.b)("inlineCode",{parentName:"p"},"app/server")," or ",Object(a.b)("inlineCode",{parentName:"p"},"server/app"),".")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-go"}),'package app\n\nimport "net/http"\n\nfunc HandleIndex(w http.ResponseWriter, _ *http.Request) {\n    w.Header().Set("Content-Length", "12")\n    w.Header().Set("Content-Type", "text/plain; charset=utf-8")\n    w.Header().Set("X-Content-Type-Options", "nosniff")\n\n    w.Write([]byte("Hello World!"))\n}\n')),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Then, let‚Äôs create a ",Object(a.b)("a",r({parentName:"li"},{href:"https://godoc.org/github.com/go-chi/chi#NewRouter"}),"new Chi router")," and bundle our handler to ",Object(a.b)("inlineCode",{parentName:"li"},'"/"')," route pattern via ",Object(a.b)("a",r({parentName:"li"},{href:"https://godoc.org/github.com/go-chi/chi#Mux.MethodFunc"}),Object(a.b)("inlineCode",{parentName:"a"},"MethodFunc()")),". I save this under ",Object(a.b)("inlineCode",{parentName:"li"},"app/router/router.go"),".")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"üí° If you are not familiar with ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/go-chi/chi"}),"Chi router"),", I recommend you to read ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/go-chi/chi/blob/master/README.md"}),"its README")," for more details. If you are new to Go, again I recommend you to read the overview of the documentation of the ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("a",r({parentName:"strong"},{href:"https://golang.org/pkg/net/http/"}),Object(a.b)("inlineCode",{parentName:"a"},"net/http")))," package before that. As you see ",Object(a.b)("a",r({parentName:"p"},{href:"https://godoc.org/github.com/go-chi/chi#Mux.MethodFunc"}),"MethodFunc()")," is matching ",Object(a.b)("a",r({parentName:"p"},{href:"https://golang.org/pkg/net/http/#HandleFunc"}),"http.HandleFunc()")," signature.")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-go"}),'package router\n\nimport (\n    "github.com/go-chi/chi"\n\n    "myapp/app/app"\n)\n\nfunc New() *chi.Mux {\n    r := chi.NewRouter()\n\n    r.MethodFunc("GET", "/", app.HandleIndex)\n\n    return r\n}\n')),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"After that, we need to update ",Object(a.b)("inlineCode",{parentName:"li"},"cmd/app/main.go")," to use our Chi router instead using ",Object(a.b)("a",r({parentName:"li"},{href:"https://golang.org/pkg/net/http/#ServeMux"}),"default HTTP route multiplexer"),"; (Line 6, 13 and 21).")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-go"}),'import (\n    "fmt"\n    "log"\n    "net/http"\n\n    "myapp/app/router"\n    "myapp/config"\n)\n\nfunc main() {\n    appConf := config.AppConfig()\n\n    appRouter := router.New()\n\n    address := fmt.Sprintf(":%d", appConf.Server.Port)\n\n    log.Printf("Starting server %s\\n", address)\n\n    s := &http.Server{\n        Addr:         address,\n        Handler:      appRouter,\n        ReadTimeout:  appConf.Server.TimeoutRead,\n        WriteTimeout: appConf.Server.TimeoutWrite,\n        IdleTimeout:  appConf.Server.TimeoutIdle,\n    }\n')),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Rebuild and rerun the application. You should see the same ",Object(a.b)("inlineCode",{parentName:"li"},"Hello World!")," response on ",Object(a.b)("inlineCode",{parentName:"li"},"localhost:8080"),". And this time, you should see the ",Object(a.b)("inlineCode",{parentName:"li"},"404 page not found")," response if you visit ",Object(a.b)("inlineCode",{parentName:"li"},"localhost:8080/invalid-path"),".")))}b.isMDXComponent=!0},70:function(e,t,n){"use strict";n.d(t,"a",function(){return p}),n.d(t,"b",function(){return u});var a=n(0),r=n.n(a),o=r.a.createContext({}),i=function(e){var t=r.a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},p=function(e){var t=i(e.components);return r.a.createElement(o.Provider,{value:t},e.children)};var c="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=function(e){var t=e.components,n=e.mdxType,a=e.originalType,o=e.parentName,p=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),c=i(t),b=n,u=c[o+"."+b]||c[b]||l[b]||a;return t?r.a.createElement(u,Object.assign({},p,{components:t})):r.a.createElement(u,p)};function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=b;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[c]="string"==typeof e?e:a,i[1]=p;for(var u=2;u<o;u++)i[u]=n[u];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);