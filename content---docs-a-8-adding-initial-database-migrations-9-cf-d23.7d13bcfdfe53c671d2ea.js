(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{64:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",function(){return o}),a.d(n,"rightToc",function(){return l}),a.d(n,"default",function(){return b});a(0);var t=a(70);function i(){return(i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function r(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o={id:"a8.adding_initial_database_migrations",title:"Adding initial database migrations"},l=[{value:"Implementing a DB adapter",id:"implementing-a-db-adapter",children:[]},{value:"Implementing a DB migration tool using Goose",id:"implementing-a-db-migration-tool-using-goose",children:[]},{value:"Adding initial SQL migrations",id:"adding-initial-sql-migrations",children:[]},{value:"Running migrations at the application startup",id:"running-migrations-at-the-application-startup",children:[]}],p={rightToc:l},s="wrapper";function b(e){var n=e.components,a=r(e,["components"]);return Object(t.b)(s,i({},p,a,{components:n,mdxType:"MDXLayout"}),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"ðŸ’­ Database migrations are like version controls for the database. There are few popular options for database migration in the Go ecosystem like ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/golang-migrate/migrate"}),Object(t.b)("inlineCode",{parentName:"a"},"golang-migrate/migrate")),", ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/pressly/goose"}),Object(t.b)("inlineCode",{parentName:"a"},"pressly/goose")),", ",Object(t.b)("a",i({parentName:"p"},{href:"http://gorm.io/docs/migration.html"}),"GORM migrations")," and etc. In here, we are using ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/pressly/goose"}),Object(t.b)("inlineCode",{parentName:"a"},"pressly/goose")),", due to its lesser resource usage and the simplicity of usage.")),Object(t.b)("h2",{id:"implementing-a-db-adapter"},"Implementing a DB adapter"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"In the previous section, inside the ",Object(t.b)("inlineCode",{parentName:"li"},"docker-compose.yml")," file, we adjusted the configurations of the MariaDB instance by setting environment variables to overwrite the default database name, username and passwords. From the Go application side, we need those configurations to connect with the database. So, letâ€™s add those to ",Object(t.b)("inlineCode",{parentName:"li"},"docker/app/.env"),".")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{}),"DB_HOST=db\nDB_PORT=3306\nDB_USER=myapp_user\nDB_PASS=myapp_pass\nDB_NAME=myapp_db\n")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"To read those from the Go application side, we need to add those to ",Object(t.b)("inlineCode",{parentName:"li"},"Conf struct")," in ",Object(t.b)("inlineCode",{parentName:"li"},"config/config.go")," file.")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-go"}),'type Conf struct {\n    Debug  bool `env:"DEBUG,required"`\n    Server serverConf\n    Db     dbConf\n}\n\ntype dbConf struct {\n    Host     string `env:"DB_HOST,required"`\n    Port     int    `env:"DB_PORT,required"`\n    Username string `env:"DB_USER,required"`\n    Password string `env:"DB_PASS,required"`\n    DbName   string `env:"DB_NAME,required"`\n}\n')),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"Go standard library provides a generic interface around SQL databases via the ",Object(t.b)("a",i({parentName:"p"},{href:"https://golang.org/pkg/database/sql/"}),Object(t.b)("inlineCode",{parentName:"a"},"database/sql"))," package. But we have to use a specific ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/golang/go/wiki/SQLDrivers"}),"database driver implementation")," according to the the database driver we use. In here we use ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/go-sql-driver/mysql"}),"go-sql-driver/mysql")," as the MariaDB driver. So we need to run ",Object(t.b)("inlineCode",{parentName:"p"},"go get github.com/go-sql-driver/mysql")," to download and install the package. As you know, this updates ",Object(t.b)("inlineCode",{parentName:"p"},"go.mod")," and ",Object(t.b)("inlineCode",{parentName:"p"},"go.sum")," files as well.")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"Letâ€™s create the database adapter in ",Object(t.b)("inlineCode",{parentName:"p"},"adapter/db/db.go"),"."))),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-go"}),'package db\n\nimport (\n    "database/sql"\n    "fmt"\n\n    "github.com/go-sql-driver/mysql"\n\n    "myapp/config"\n)\n\nfunc New(conf *config.Conf) (*sql.DB, error) {\n    cfg := &mysql.Config{\n        Net:                  "tcp",\n        Addr:                 fmt.Sprintf("%v:%v", conf.Db.Host, conf.Db.Port),\n        DBName:               conf.Db.DbName,\n        User:                 conf.Db.Username,\n        Passwd:               conf.Db.Password,\n        AllowNativePasswords: true,\n        ParseTime:            true,\n    }\n\n    return sql.Open("mysql", cfg.FormatDSN())\n}\n')),Object(t.b)("h2",{id:"implementing-a-db-migration-tool-using-goose"},"Implementing a DB migration tool using Goose"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"We need to run ",Object(t.b)("inlineCode",{parentName:"p"},"go get github.com/pressly/goose")," to download and install the package.")),Object(t.b)("li",{parentName:"ul"},Object(t.b)("p",{parentName:"li"},"Letâ€™s create a custom ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/pressly/goose"}),Object(t.b)("inlineCode",{parentName:"a"},"pressly/goose"))," binary. A good example can be found in ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/pressly/goose/blob/master/cmd/goose/main.go"}),Object(t.b)("inlineCode",{parentName:"a"},"https://github.com/pressly/goose/blob/master/cmd/goose/main.go")),". We save this under ",Object(t.b)("inlineCode",{parentName:"p"},"cmd/migrate/main.go")," with few modifications to remove few unnecessary codes, due to we are using only MariaDB in our application."))),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "flag"\n    "fmt"\n    "log"\n    "os"\n\n    "github.com/pressly/goose"\n\n    "myapp/adapter/db"\n    "myapp/config"\n)\n\nconst dialect = "mysql"\n\nvar (\n    flags = flag.NewFlagSet("migrate", flag.ExitOnError)\n    dir   = flags.String("dir", "/myapp/migrations", "directory with migration files")\n)\n\nfunc main() {\n    flags.Usage = usage\n    flags.Parse(os.Args[1:])\n\n    args := flags.Args()\n    if len(args) == 0 || args[0] == "-h" || args[0] == "--help" {\n        flags.Usage()\n        return\n    }\n\n    command := args[0]\n    switch command {\n    case "create":\n        if err := goose.Run("create", nil, *dir, args[1:]...); err != nil {\n            log.Fatalf("migrate run: %v", err)\n        }\n        return\n    case "fix":\n        if err := goose.Run("fix", nil, *dir); err != nil {\n            log.Fatalf("migrate run: %v", err)\n        }\n        return\n    }\n\n    appConf := config.AppConfig()\n    appDb, err := db.New(appConf)\n    if err != nil {\n        log.Fatalf(err.Error())\n    }\n\n    defer appDb.Close()\n\n    if err := goose.SetDialect(dialect); err != nil {\n        log.Fatal(err)\n    }\n\n    if err := goose.Run(command, appDb, *dir, args[1:]...); err != nil {\n        log.Fatalf("migrate run: %v", err)\n    }\n}\n\nfunc usage() {\n    fmt.Println(usagePrefix)\n    flags.PrintDefaults()\n    fmt.Println(usageCommands)\n}\n\nvar (\n    usagePrefix = `Usage: migrate [OPTIONS] COMMAND\nExamples:\n    migrate status\nOptions:\n`\n\n    usageCommands = `\nCommands:\n    up                   Migrate the DB to the most recent version available\n    up-by-one            Migrate the DB up by 1\n    up-to VERSION        Migrate the DB to a specific VERSION\n    down                 Roll back the version by 1\n    down-to VERSION      Roll back to a specific VERSION\n    redo                 Re-run the latest migration\n    reset                Roll back all migrations\n    status               Dump the migration status for the current DB\n    version              Print the current version of the database\n    create NAME [sql|go] Creates new migration file with the current timestamp\n    fix                  Apply sequential ordering to migrations\n`\n)\n')),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"ðŸ’¡ If you are not familiar with ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/pressly/goose"}),Object(t.b)("inlineCode",{parentName:"a"},"pressly/goose")),", now itâ€™s the time to read ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/pressly/goose/blob/master/README.md"}),"its README")," for more details. Also in here, we are going to use only ",Object(t.b)("inlineCode",{parentName:"p"},".sql")," migrations. So, I set the migrations directory to ",Object(t.b)("inlineCode",{parentName:"p"},"/myapp/migrations"),".")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"Due to we need to build this package and copy the binary file to the smaller alpine image with ",Object(t.b)("inlineCode",{parentName:"li"},".sql")," migration files, we have to update ",Object(t.b)("inlineCode",{parentName:"li"},"docker/app/Dockerfile"),"; (Line 1,2,11,12).")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-dockerfile"}),"RUN go build -ldflags '-w -s' -a -o ./bin/app ./cmd/app \\\n    && go build -ldflags '-w -s' -a -o ./bin/migrate ./cmd/migrate\n\n\n# Deployment environment\n# ----------------------\nFROM alpine\nRUN apk update && apk add --no-cache bash\n\nCOPY --from=build-env /myapp/bin/app /myapp/\nCOPY --from=build-env /myapp/bin/migrate /myapp/\nCOPY --from=build-env /myapp/migrations /myapp/migrations\n")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"Rebuild and rerun the application. Login to ",Object(t.b)("inlineCode",{parentName:"li"},"myapp_app_1")," container by running ",Object(t.b)("inlineCode",{parentName:"li"},"docker exec -it myapp_app_1 bash")," and run ",Object(t.b)("inlineCode",{parentName:"li"},"/myapp/migrate status"),". You should see no migrations available.")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{}),"Applied At                  Migration\n=====================================\n")),Object(t.b)("h2",{id:"adding-initial-sql-migrations"},"Adding initial SQL migrations"),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"As mentioned in the very beginning of this post, we are building a RESTful CRUD API for a bookshelf. So, letâ€™s create our first ",Object(t.b)("inlineCode",{parentName:"li"},"sql")," migration file to create ",Object(t.b)("inlineCode",{parentName:"li"},"books")," table under ",Object(t.b)("inlineCode",{parentName:"li"},"migrations/20190805170000_create_books_table.sql"),".")),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"ðŸ’¡ We can use ",Object(t.b)("inlineCode",{parentName:"p"},"create")," command of our goose binary; ex: ",Object(t.b)("inlineCode",{parentName:"p"},"/myapp/migrate create create_books_table sql"),".")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-sql"}),"-- +goose Up\n-- SQL in this section is executed when the migration is applied.\nCREATE TABLE IF NOT EXISTS books\n(\n    id             INT UNSIGNED NOT NULL AUTO_INCREMENT,\n    title          VARCHAR(255) NOT NULL,\n    author         VARCHAR(255) NOT NULL,\n    published_date DATE         NOT NULL,\n    image_url      VARCHAR(255) NULL,\n    description    TEXT         NULL,\n    created_at     TIMESTAMP    NOT NULL,\n    updated_at     TIMESTAMP    NULL,\n    deleted_at     TIMESTAMP    NULL,\n    PRIMARY KEY (id)\n);\n\n-- +goose Down\n-- SQL in this section is executed when the migration is rolled back.\nDROP TABLE IF EXISTS books;\n")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"Rebuild and rerun the application. Login to ",Object(t.b)("inlineCode",{parentName:"li"},"myapp_app_1")," container by running ",Object(t.b)("inlineCode",{parentName:"li"},"docker exec -it myapp_app_1 bash")," and run ",Object(t.b)("inlineCode",{parentName:"li"},"/myapp/migrate status"),". Now, you should see one pending migration is available.")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{}),"Applied At        Migration\n==========================================================\nPending           -- 20190805170000_create_books_table.sql\n")),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"ðŸ’¡ We can run migrations manually with ",Object(t.b)("inlineCode",{parentName:"p"},"/myapp/migrate up")," command. But, letâ€™s see how to automate running migrations in the development environment.")),Object(t.b)("h2",{id:"running-migrations-at-the-application-startup"},"Running migrations at the application startup"),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"ðŸ”Ž This step is quite tricky, due to we need to wait till ",Object(t.b)("inlineCode",{parentName:"p"},"myapp_bd_1")," container starts, to run database migrations. Otherwise, ",Object(t.b)("inlineCode",{parentName:"p"},"myapp_app_1")," will be stopped with an error, if migrations run before creating the database.")),Object(t.b)("p",null,"ðŸ’¡ In here, I am going to install ",Object(t.b)("inlineCode",{parentName:"p"},"mysql-client")," package to the ",Object(t.b)("inlineCode",{parentName:"p"},"myapp_app")," docker image and wait till database is running, by checking the database connection via a ",Object(t.b)("a",i({parentName:"p"},{href:"https://dev.mysql.com/doc/refman/8.0/en/mysql.html"}),"MySQL command-line client")," call."),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"Letâ€™s save the script which checks the database connection, under ",Object(t.b)("inlineCode",{parentName:"li"},"docker/app/bin/wait-for-mysql.sh"),".")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-sh"}),'#!/usr/bin/env bash\n\nhost="$1"\nshift\ncmd="$@"\n\nuntil mysql -h "$host" -u ${DB_USER} -p${DB_PASS} ${DB_NAME} -e \'select 1\'; do\n  >&2 echo "MySQL is unavailable - sleeping"\n  sleep 1\ndone\n\n>&2 echo "Mysql is up - executing command"\nexec $cmd\n')),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"We need to update the ",Object(t.b)("inlineCode",{parentName:"li"},"docker/app/Dockerfile")," file, to install ",Object(t.b)("inlineCode",{parentName:"li"},"mysql-client"),", copy above script to the deployment environment and make them executable; (Line 4, 10,11).")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-dockerfile"}),'# Deployment environment\n# ----------------------\nFROM alpine\nRUN apk update && apk add --no-cache bash mysql-client\n\nCOPY --from=build-env /myapp/bin/app /myapp/\nCOPY --from=build-env /myapp/bin/migrate /myapp/\nCOPY --from=build-env /myapp/migrations /myapp/migrations\n\nCOPY --from=build-env /myapp/docker/app/bin /usr/local/bin/myapp/\nRUN chmod +x /usr/local/bin/myapp/*\n\nEXPOSE 8080\nCMD ["/myapp/app"]\n')),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"To run migrations at the applications startup and delete ",Object(t.b)("inlineCode",{parentName:"li"},"mysql-client")," after running migrations, letâ€™s use this under ",Object(t.b)("inlineCode",{parentName:"li"},"docker/app/bin/init.sh"),". ")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-sh"}),"#!/usr/bin/env bash\necho 'Runing migrations...'\n/myapp/migrate up > /dev/null 2>&1 &\n\necho 'Deleting mysql-client...'\napk del mysql-client\n\necho 'Start application...'\n/myapp/app\n")),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},"ðŸ’¡ Due to we already copy files in ",Object(t.b)("inlineCode",{parentName:"p"},"docker/app/bin")," to deployment environment, no need to update ",Object(t.b)("inlineCode",{parentName:"p"},"docker/app/Dockerfile"),".")),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"Letâ€™s use above scripts inside ",Object(t.b)("inlineCode",{parentName:"li"},"docker-compose.yml")," to safely run migrations after database starts.")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-yml"}),'depends_on:\n    - db\ncommand: ["/usr/local/bin/myapp/wait-for-mysql.sh", "db", "/usr/local/bin/myapp/init.sh"]\n')),Object(t.b)("ul",null,Object(t.b)("li",{parentName:"ul"},"Rebuild and rerun the application. You can see that database migrations are running while starting the application by reviewing the logs.")))}b.isMDXComponent=!0},70:function(e,n,a){"use strict";a.d(n,"a",function(){return l}),a.d(n,"b",function(){return c});var t=a(0),i=a.n(t),r=i.a.createContext({}),o=function(e){var n=i.a.useContext(r),a=n;return e&&(a="function"==typeof e?e(n):Object.assign({},n,e)),a},l=function(e){var n=o(e.components);return i.a.createElement(r.Provider,{value:n},e.children)};var p="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},b=function(e){var n=e.components,a=e.mdxType,t=e.originalType,r=e.parentName,l=function(e,n){var a={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===n.indexOf(t)&&(a[t]=e[t]);return a}(e,["components","mdxType","originalType","parentName"]),p=o(n),b=a,c=p[r+"."+b]||p[b]||s[b]||t;return n?i.a.createElement(c,Object.assign({},l,{components:n})):i.a.createElement(c,l)};function c(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var r=a.length,o=new Array(r);o[0]=b;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:t,o[1]=l;for(var c=2;c<r;c++)o[c]=a[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"}}]);